import json
from typing import List

from tqdm import tqdm
from random import shuffle

from data.AggregatedSolution import AggregatedSolution
from data.Finding import Finding
from ai.LLM.LLMServiceStrategy import LLMServiceStrategy
from ai.Clustering.AgglomerativeClusterer import AgglomerativeClusterer

import logging

from utils.tqdm_utils import conditional_tqdm

logger = logging.getLogger(__name__)


class VulnerabilityReport:
    def __init__(self):
        self.findings: list[Finding] = []
        self.aggregated_solutions: List[AggregatedSolution] = []

    def set_llm_service(self, llm_service: "LLMServiceStrategy"):
        """
        This function sets the LLMServiceStrategy object for the VulnerabilityReport and all its findings.
        :param llm_service: The LLMServiceStrategy object to use.
        :return: The VulnerabilityReport object.
        """
        for finding in self.findings:
            finding.llm_service = llm_service
        return self

    def add_finding(self, finding):
        self.findings.append(finding)

    def get_findings(self):
        return self.findings

    def add_category(self):
        """
        This function adds a category to each finding in the report.
        :return: The VulnerabilityReport object.
        """
        for finding in tqdm(self.findings):
            finding.add_category()
        return self

    def add_unsupervised_category(self, use_solution=True):
        """
        This function adds a category to each finding in the report.
        :return: The VulnerabilityReport object and the AgglomerativeClustering object (in case you wanna have a look at the graph)
        """
        clustering = AgglomerativeClusterer(self)
        if use_solution and not all(
            [finding.solution is not None for finding in self.findings]
        ):
            logger.warning(
                "Not all findings have a solution, falling back to using the description."
            )
            use_solution = False

        clustering.add_unsupervised_category(use_solution=use_solution)
        return self, clustering

    def add_solution(self, long=True, short=True, search_term=True):
        """
        This function generates solutions for each finding in the report.
        :param long: Whether to generate long recommendations.
        :param short: Whether to generate short recommendations.
        :param search_term: Whether to generate search terms.
        :return: The VulnerabilityReport object.
        """
        for finding in tqdm(self.findings):
            finding.generate_solution(long, short, search_term)
        return self

    def set_aggregated_solutions(self, aggregated_solutions: List[AggregatedSolution]):
        self.aggregated_solutions = aggregated_solutions

    def get_aggregated_solutions(self) -> List[AggregatedSolution]:
        return self.aggregated_solutions

    def sort(self, by: str = "severity", reverse: bool = True):
        """
        This function sorts the findings by severity or priority.
        :param reverse:  Whether to sort in reverse order.
        :param by: The key to sort by. Options are 'severity' or 'priority'.
        :return: The sorted VulnerabilityReport object.
        """
        if by == "severity":
            self.findings.sort(key=lambda x: x.severity, reverse=reverse)
        elif by == "priority":
            self.findings.sort(key=lambda x: x.priority, reverse=reverse)
        else:
            raise ValueError(
                f"Invalid sorting key: {by}. Options are 'severity' or 'priority'."
            )

        return self

    def to_dict(self):
        findings = [f.to_dict() for f in self.findings]
        if len(self.get_aggregated_solutions()) > 0:
            aggregated_solutions = [
                f.to_dict() for f in self.get_aggregated_solutions()
            ]
            return {"findings": findings, "aggregated_solutions": aggregated_solutions}
        return {"findings": findings}

    def __str__(self):
        findings_str = "\n".join([str(f) for f in self.findings])
        if len(self.get_aggregated_solutions()) > 0:
            aggregated_solutions_str = "\n".join(
                [str(f) for f in self.get_aggregated_solutions()]
            )
            return findings_str + "\n\n" + aggregated_solutions_str
        return findings_str

    def to_html(self, table=False):
        my_str = "<br/>".join([f.to_html(table) for f in self.findings])
        if len(self.get_aggregated_solutions()) > 0:
            my_str += "<br/><br/>" + "<br/>".join(
                [f.to_html() for f in self.get_aggregated_solutions()]
            )
        return my_str

    def export_to_json(self, filename="VulnerabilityReport.json"):
        """
        This function exports the VulnerabilityReport object to a JSON file.
        :param filename: The filename to save the JSON file to.
        :return: None
        """
        with open(filename, "w") as f:
            json.dump(self.to_dict(), f)
        return None

    @staticmethod
    def import_from_json(filename="VulnerabilityReport.json"):
        """
        This function imports a VulnerabilityReport object from a JSON file.
        :param filename: The filename to import the JSON file from.
        :return: The VulnerabilityReport object.
        """
        with open(filename, "r") as f:
            data = json.load(f)
        report = VulnerabilityReport()
        for d in data:
            finding = Finding(**d)
            report.add_finding(finding)
        return report


def create_from_flama_json(
    json_data,
    n=-1,
    llm_service: "LLMServiceStrategy" = None,
    shuffle_data=False,
    combine_descriptions=True,
) -> VulnerabilityReport:
    """
    This function creates a VulnerabilityReport object from a JSON object.
    :param shuffle_data:  Whether to shuffle the findings before selecting n. Selecting True will give a random sample of n findings.
    :param n:  The number of findings to include in the report, -1 for all.
    :param llm_service: The LLMServiceStrategy object to use for generating recommendations, if not provided a new one will be created (for each finding).
    :param json_data: The Flama export, either top-level or nested in a 'message' key.
    :param combine_descriptions: Whether to combine the descriptions of the findings.
    :return: a new and shiny VulnerabilityReport object.
    """

    if "message" in json_data:
        json_data = json_data["message"]["content"]

    vulnerability_report = VulnerabilityReport()

    if n == -1:
        n = len(json_data)
    else:
        n = min(n, len(json_data))
        if shuffle_data:
            # shuffle json_data to get a random sample
            shuffle(json_data)

    for d in conditional_tqdm(
        json_data[:n], combine_descriptions, desc="Combining descriptions"
    ):
        title = [x["element"] for x in d["title_list"]]
        source = set([x["source"] for x in d["title_list"]])
        description = [x["element"] for x in d.get("description_list", [])]
        cwe_ids = [", ".join(x["element"]) for x in d.get("cwe_id_list", [])]
        cve_ids = (
            [x["element"] for x in d.get("cve_id_list", [])]
            if "cve_id_list" in d
            else []
        )
        severity = d.get("severity", None)
        priority = d.get("priority", None)

        locations = []
        for loc in d.get("location_list", []):
            try:
                location = json.loads(
                    loc["location"].replace("'", '"')
                )  # This is a hack to fix the single quotes in the JSON
            except json.JSONDecodeError:
                locations.append(loc["location"])
                continue

            file = location.get("file", "")
            line = location.get("line", "")
            column = location.get("column", "")

            location_str = f"{file}:{line}, {column}"

            locations.append(location_str)

        finding = Finding(
            title=title,
            source=source,
            descriptions=description,
            cwe_ids=cwe_ids,
            cve_ids=cve_ids,
            severity=severity,
            priority=priority,
            location_list=locations,
        )
        finding._llm_service = llm_service

        # Combine descriptions
        if combine_descriptions:
            finding.combine_descriptions()

        vulnerability_report.add_finding(finding)
    return vulnerability_report
